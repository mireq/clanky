<!DOCTYPE html>
<html>
<head>
	<title>Uwsgi multihosting s monitoringom cez grafana</title>
	<meta charset="utf-8" />
	<link href="../../../common/style.css" rel="stylesheet" />
</head>
<body>
<article data-title-image="img/title_image.jpg">

<header>
	<h1>Uwsgi multihosting s monitoringom cez grafana</h1>

	<p></p>
</header>

<p>Ako server som zvolil Ubuntu Server 23.10. Postup by mal s malými zmenami fungovať prakticky na ľubovoľnej distribúcii založenej na Debian Linuxe. Všetky príkazy budú vykonávané ak to nebude uvedené inak pod používateľom <code>root</code>. V príkazoch preto nebudem uvádzať <code>sudo</code> a budem predpokladať, že používateľ je priamo prihlásený ako root (napríklad príkazom <code>sudo su</code>).</p>

<h2>Vytváranie používateľov a adresárovej štruktúry</h2>

<p>Na serveri bude niekoľko projektov a potenciálne aj niekoľko používateľov. Preto som navrhol nasledujúci spôsob správy používateľov a ich adresárov:</p>

<ul>
	<li>Každý web má vlastného používateľa (bez možnosti prihlásenia)</li>
	<li>Každý web (synonymu pre používateľa) je priradený v skupine <code>www-data</code> a v stkupine, ktorá je vytvorená pre klienta</li>
	<li>Používatelia majú svoje domovské adresáre v <code>/var/www/clients/&lt;skupina&gt;/&lt;používateľ&gt;</code></li>
	<li>Každý používateľ má meno podľa hlavnej domény webu (napríklad pre <code>linuxos.sk</code> by sa volal <code>linuxos.sk</code> a mal by svoju skupinu <code>linuxos-team</code>, <code>www-data</code>)</li>
	<li>Používateľský adresár má odkaz do <code>/var/www</code> napríklad <code>/var/www/linuxos.sk</code></li>
</ul>

<p>Pre stránku <code>linuxos.sk</code> by išlo o nasledujúce príkazy:</p>

<pre class="code-bash">
# vytvorenie skupiny
groupadd linuxos-team

# vytvorenie užívateľského adresára (s jedným podadresárom web)
mkdir -p /var/www/clients/linuxos-team/linuxos.sk/web

# zmena práv pre home adresár
chown linuxos.sk:linuxos-team /var/www/clients/linuxos-team/linuxos.sk/

# pridanie používateľa bez možnosti prihlásenia
useradd -d /var/www/clients/linuxos-team/linuxos.sk -g linuxos-team -M -s /bin/false linuxos.sk

# pridanie používateľa do skupiny www-data
usermod -a -G www-data linuxos.sk

# vytvorenie odkazu
ln -s /var/www/clients/linuxos-team/linuxos.sk /var/www/linuxos.sk
</pre>

<p>Keďže proces pridávania používateľov je vážne nudný a repetitívny a my programátori neradi robíme tie isté veci stále a stále znovu nehovoriac o vyhľadávaní návodu, pripravil som si bash skript, ktorý túto úlohu vyrieši za mňa. Povedzme, že nasledujúci skript si pomenujem <code>web_user_add</code>:</p>

<pre class="code-bash">
#!/bin/bash

# Nápoveda
if [ "$#" -ne 3 ]; then
	echo "web_add host system_user system_group"
	exit -1
fi

host=$1
sys_user=$2
sys_group=$3

# Nie je vytvorená skupina? Vytvoríme
if [[ ! $(getent group $sys_group) ]]; then
	groupadd $sys_group
	usermod -a -G $sys_group www-data
fi

# Nie je vytvorený používateľ? Vytvoríme
if [[ ! $(getent passwd $sys_user) ]]; then
	mkdir -p /var/www/clients/$sys_group/$sys_user/web
	chown $sys_user:$sys_group -R /var/www/clients/$sys_group/$sys_user
	useradd -d /var/www/clients/$sys_group/$sys_user -g $sys_group -M -s /bin/false $sys_user
	usermod -a -G www-data $sys_user
fi

# Vytvorenie odkazu
ln -s /var/www/clients/$sys_group/$sys_user /var/www/$host
</pre>

<p>Teraz už stačí len spustiť <code>./web_user_add linuxos.sk linuxos.sk linuxos-team</code>.</p>

<h2>Uwsgi server</h2>

<p>Zvyčajne prevádzkujem klasické <a href="https://en.wikipedia.org/wiki/Web_Server_Gateway_Interface">Web Server Gateway Interface</a> aplikácie. Existuje množstvo čistých wsgi, alebo kombinovaných asgi / wsgi serverov. Ja konkrétne používam <a href="https://uwsgi-docs.readthedocs.io/en/latest/">uWSGI</a>, čo je dnes považované už prakticky za neudržiavanú vykopávku. Má však veľmi zaujímavé vlastnosti, ktoré som v iných serveroch nenašiel, napríklad podporu socketovej aktivácie, automatické škálovanie, monitoring, routing, plánovanie úloh na pozadí atď.</p>

<p>Najjednoduchšou voľbou, ako začať s multi-app deploymentom je <a href="https://uwsgi-docs.readthedocs.io/en/latest/Emperor.html">uWSGI Emperor</a>. Tento režim umožňuje spravovať niekoľko aplikácii súbežne. Zároveň zvláda automatické spúšťanie nových workerov pri záťaži, či naopak ich vypínanie v prípade, že už nie sú potrební. Ako čerešničku na torte by som spomenul možnosť <a href="https://uwsgi-docs.readthedocs.io/en/latest/Options.html#cheap">cheap</a>, pri ktorej sa počas štartu len vytvorí socket a prvý worker sa spustí až pri požiadavke.</p>

<p>Dosť bolo marketingových kecov, nastal čas vyhrnúť si rukávy a konfigurovať. Upozorňujem, že táto časť nie je nič, pre slabšie povahy a bude zahŕňať pomerne pokročilé techniky, na ktoré autor prišiel pri všetkej skromnosti sám a stálo ho to nemalé úsilie.</p>

<p>Začnem inštaláciou <code>uwsgi</code> serveru, ktorá je na distribúciach založených na debiane veľmi jednoduchá - <code>apt install uwsgi-plugin-python3</code>.</p>

<p>Konfiguráciu začnem prvým a hlavným konfiguračným súborom pre <em>uwsgi emperor</em> - <code>/etc/uwsgi/emperor.ini</code>. Súbor odkazuje na ďalšie konfiguračné súbory a nástroje, ktoré si postupne prejdeme. Tu je už sľúbená konfigurácia:</p>

<pre class="code-ini">
[uwsgi]
plugin = syslog
logger = syslog:emperor

master-fifo = /run/uwsgi/emperor.fifo

emperor = /etc/uwsgi/apps-enabled
emperor-stats = /run/uwsgi/emperor-stats.sock
emperor-on-demand-exec = /etc/uwsgi/make_rundir.py

vassals-inherit = /etc/uwsgi/default-inherit.ini
vassals-include-before = /etc/uwsgi/default-include-before.ini

#emperor-tyrant = true
#cap = setgid,setuid
</pre>

<p>Prvé 2 direktívy zapínajú logovanie do syslogu pod identifikátorom <code>emperor</code>. Pomocou tohto identifikátora bude neskôr možné identifikovať logy pochádzajúce z hlavného procesu. Ak je logovanie nastavené správne, výsledné logy vyzerajú približne takto:</p>

<pre>
Sat Nov 18 13:13:19 2023 - [emperor] vassal linuxos.sk.ini is ready to accept requests
Sat Nov 18 13:13:21 2023 - [emperor] vassal linuxos.sk.ini is now loyal
</pre>

<p>Direktíva <code>master-fifo</code> umožňuje ovládať emperor pomocou <a href="https://uwsgi-docs.readthedocs.io/en/latest/MasterFIFO.html">sady príkazov</a>. Osobne som z týchto možností nevyužil ešte reálne nič okrem preskenovania konfigurácie (<code>echo "E" &gt; /run/uwsgi/emperor.fifo</code>).</p>

<p>Pod direktívou <code>emperor</code> sa skrýva cesta ku konfigurácii k jednotlivým webom (<em>vassals</em>). V tomto prípade je to adresár s konfiguračnými súbormi, ale reálne tu môže byť napríklad nastavená aj konfigurácia pre výber konfigurácie z postgresql databázy. Podrobnejšie informácie sa nachádzajú v <a href="https://uwsgi-docs.readthedocs.io/en/latest/Emperor.html">dokumentácii</a>.</p>

<p>Štatistiky o jednotlivých weboch a procesoch sa dajú exportovať cez direktívu <code>emperor-stats</code>.</p>

<p>Pod podozrivou direktívou <code>emperor-on-demand-exec</code> sa dokonca skrýva cesta k skriptu. K jeho úlohe sa vrátim v časti o spúšťaní on demand.</p>

<p>Nasledujúce direktívy <code>vassals-inherit</code> a <code>vassals-include-before</code> definujú spoločnú konfiguráciu pre všetky weby. Stále platí, že som lenivý programátor, ktorému sa nechce všetko konfigurovať pre každý web. Prečo sú však direktívy 2?</p>

<p>Existujú 2 direktívy pre vloženie spoločnej konfigurácie <code>inherit</code> a <code>include</code>. Okrem toho existujú ešte v 2 variantoch a to príponou <code>-before</code> kedy sú akoby vložené na začiatok konfiguračného súboru a bez prípony, kedy sú na konci. Rozdiel medzi <code>inherit</code> a <code>include</code> spočíva v expanzii environment premenných a v tomto prípade rozdiel nie je dôležitý. Čo je však dôležité je prípona <code>-before</code>, bez ktorej by nebolo možné "prebiť" globálne nastavenia špecifickými nastaveniami v konfigurácii konkrétneho webu. Podrobnosti o spôsobe spracovania konfiguračného súboru sú v <a href="https://uwsgi-docs.readthedocs.io/en/latest/ParsingOrder.html">dokumentácii</a>.</p>

<p>Paranoidní používatelia môžu využiť režim <code>emperor-tyrant</code>, pri ktorom weby rovno štartujú s obmedzenými právami. V bežnom režime naopak štartujú s právami, ktoré má emperor a na základe konfigurácie svoje práva degradujú (ešte v čase pred spustením kódu používateľa).</p>

<h3>Globálne nastavenia webov</h3>

<p>Súbor <code>default-inherit.ini</code> bude obsahovať všetky nastavenia, ktoré nebude možné prepísať v konfiguračných súboroch jednotlivých webov.</p>

<pre class="code-ini">
[uwsgi]
plugin = syslog
logger = syslog:%N
logformat = %(method) %(status) %(msecs)ms %(size)b %(uri)

master = 1

# limit pre beh skriptu
harakiri = 60
harakiri-verbose = 1

# automatické vypnutie procesu
cheap = true
idle = 3600
die-on-idle = true

# nastavenie ciest
chdir = /var/www/%N/web/app
pythonpath = /var/www/%N/web/app
virtualenv = /var/www/%N/web/virtualenv

# python modul
module = wsgi

chmod-socket = 660

stats = /run/uwsgi/stats/%N.sock
memory-report = true

safe-pidfile = /run/uwsgi/apps/%N/pid

#cgroup = /sys/fs/cgroup/cpu/uwsgi/%N
#cgroup = /sys/fs/cgroup/memory/uwsgi/%N
#cgroup-opt = memory.limit_in_bytes = 6442450944
</pre>

<p>Na začiatku súboru je opäť nastavenie logov. Magická premenná <code>%N</code> obsahuje názov hlavného konfiguračného súboru bez prípony. Konfiguračný súbor webu bude mať názov <code>linuxos.sk.ini</code>, takže táto magická premenná bude obsahovať <code>linuxos.sk</code>. Syslog identifikátor bude preto obsahovať názov domény <code>linuxos.sk</code>, čo nám umožní filtrovať logy podľa konkrétneho webu.</p>

<p>Direktíva <code>master</code> určuje spôsob vytvorenia procesu. V zásade platí, že procesy webu by mali mať nastavenú direktívu <code>master</code> a emperor nie.</p>

<p>Pomocou direktívy <code>harakiri</code> sa nastavuje čas, po ktorom sa zabije worker ak nebude odpovedať.</p>

<p>Nasledujúca časť s direktívami <code>cheap</code>, <code>idle</code> a <code>die-on-idle</code> povoľuje aktiváciu socketom a časovač, ktorý vypne inštanciu, ak po zvolenú dobu nebude prijatá žiada požiadavka.</p>

<p>Nasleduje konfigurácia ciest. Tu sú použité magické premenné, ktoré zložia cestu z názvu hlavného konfiguračného súboru.</p>

<p>Pomocou direktívy <code>module</code> sa nastavuje python modul, ktorý bude obsahovať entry point aplikácie (funkciu <code>application</code>).</p>

<p>Vytvorený socket má mať práva <code>600</code>, teda plný prístup pre používateľa a skupinu.</p>

<p>Každý projekt bude mať vlastný socket, cez ktorý sa dajú čítať štatistiky. Direktívou <code>memory-report</code> sa zapína export informácií o obsadenej pamäti do súboru so štatistikami.</p>

<p>Nakoniec zostáva už len nastavenie PID súboru.</p>

<p>Ak používate cgroups v1, je možné nastaviť limity priamo pre worker. Žiaľ podpora v2 v dobe písania nie je implementovaná.</p>

<p>V súbore <code>default-include-before.ini</code> budú naopak direktívy, ktoré sa môžu v jednotlivých weboch prepísať.</p>

<pre class="code-ini">
[uwsgi]
processes = 4

cheaper = 1
cheaper-initial = 1
cheaper-step = 1

uid = www-data
gid = www-data
chown-socket = www-data:www-data
</pre>

<p>V tomto súbore nastavujem najskôr počet workerov. V tomto prípade je počet workerov limitovaný na 4.</p>

<p>Ďalej nasleduje nastavenie automatického škálovania pomocou direktív <code>cheaper</code>. Škálovanie sa začína na 1 procese a počet procesov sa zvyšuje / znižuje po 1 procese.</p>

<p>Nakoniec sa nastavuje používateľ / skupina procesu a práva pre socket.</p>

<h3>Spustenie on demand</h3>

<p>Pri inicializácii on-demand inštancie môže uwsgi emperor spustiť ľubovoľný skript. Účelom skriptu je príprava prostredia pre beh webu. Môže napríklad vytvárať potrebné adresáre. Nakoniec musí vrátiť cestu k unix socket súboru. Takto konkrétne vyzerá môj <code>/etc/uwsgi/make_rundir.py</code>:</p>

<pre class="code-python">
#!/usr/bin/env python3

import configparser
import grp
import os
import pwd
import socket
import sys

# uwsgi posiela názov konfiguračného úboru ako args[1]
confname = sys.argv[1]
basename = os.path.basename(confname)
appname = os.path.splitext(basename)[0]

# načítanie konfigurácie
config = configparser.ConfigParser(strict=False)
config.read(confname)

# vytvorenie adresára so štatistikami
dirname = '/run/uwsgi/stats/'
try:
	os.makedirs(dirname)
except OSError:
	pass
uid = pwd.getpwnam('www-data').pw_uid
gid = grp.getgrnam('www-data').gr_gid
os.chown(dirname, uid, gid)
os.chmod(dirname, 504) # 770

# vytvorenie socketu pre štatistiky
stats_socket_file = f'/run/uwsgi/stats/{appname}.sock'
try:
	os.unlink(stats_socket_file)
except OSError:
	pass
sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
sock.bind(stats_socket_file)

# vytvorenie /run/uwsgi/apps
dirname = '/run/uwsgi/apps/%s' % appname
try:
	os.makedirs(dirname)
except OSError:
	pass

# načítanie uid / gid zo súboru
config = dict(config.items('uwsgi'))
config.setdefault('uid', 'www-data')
config.setdefault('gid', 'www-data')

# nastavenie práv
uid = pwd.getpwnam(config['uid']).pw_uid
gid = grp.getgrnam(config['gid']).gr_gid
perms = '%s:%s' % (config['uid'], config['gid'])

if uid == 0 or gid == 0:
	sys.stderr.write("Dangerous")
	sys.exit(-1)

os.chown(dirname, uid, gid)
os.chmod(dirname, 504) # 770
os.chown(stats_socket_file, uid, gid)
os.chmod(stats_socket_file, 432) # 660

# vrátenie cesty k socketu
sys.stdout.write('%s/socket' % dirname)
</pre>

<h3>Konfigurácia webovej aplikácie</h3>

<p>Konfiguráciu webových aplikácií umiestňujem štandardne do adresára <code>/etc/uwsgi/apps-available</code>. V adresári <code>/etc/uwsgi/apps-enabled</code> sú symbolické odkazy na súbory v <code>apps-available</code>, čo umožňuje jednoducho zapínať / vypínať weby vytvorením či zmazaním odkazu.</p>

<p>Kompletná konfigurácia <code>linuxos.sk.ini</code> môže vyzerať napríklad takto:</p>

<pre class="code-ini">
[uwsgi]
plugins = python3

processes = 8

uid = linuxos.sk
gid = linuxos-team
chown-socket = linuxos.sk:linuxos-team
</pre>

<h3>Webová aplikácia</h3>

<p>Teraz si v adresári <code>/var/www/linuxos.sk/web</code> vytvoríme ukážkovú aplikáciu.</p>

<p>Najskôr v adresári vytvoríme python virtualenv prostredie príkazom <code>python3 -m venv virtualenv</code>. Aplikácia bude umiestnená v podadresári <code>app</code> ako súbor <code>wsgi.py</code>. Kompletný súbor vyzerá takto:</p>

<pre class="code-python">
def application(env, start_response):
	start_response('200 OK', [('Content-Type','text/html')])
	return [b"Hello World"]
</pre>

<h3>Spustenie systémovej služby</h3>

<p>Na dokončenie konfigurácie zostáva jediná drobnosť - vytvorenie systémovej služby pre spustenie uwsgi. V adresári <code>/etc/systemd/system</code> vytvoríme súbor <code>emperor.uwsgi.service</code>.</p>

<pre class="code-ini">
[Unit]
Description=uWSGI Emperor
After=syslog.target

[Service]
ExecStartPre=/bin/mkdir -p /run/uwsgi
ExecStart=/usr/bin/uwsgi --ini /etc/uwsgi/emperor.ini
ExecReload=/bin/echo "E" &gt; /run/uwsgi/emperor.fifo
Restart=always
KillSignal=SIGQUIT
Type=notify
NotifyAccess=all

[Install]
WantedBy=multi-user.target
</pre>

<p>Tu sa nastavujú príkazy pre vytvorenie pracovného adresára, spustenie daemona, alebo načítanie adresára s konfiguračnými súbormi poslaním písmena <code>E</code> do riadiacej rúry <code>/run/uwsgi/emperor.fifo</code>.</p>

<p>Služba sa následne naštartuje príkazom <code>systemctl start emperor.uwsgi.service</code>.</p>

<p>Logy sa dajú sledovať príkazom <code>journalctl -f -u emperor.uwsgi.service</code>. Je možné filtrovať logy podľa jednotlivých identifikátorov, napríklad <code>journalctl -f -u emperor.uwsgi.service SYSLOG_IDENTIFIER=emperor</code> pre sledovanie hlavného procesu, alebo <code>SYSLOG_IDENTIFIER=linuxos.sk</code> pre sledovanie logov pre konkrétny web.</p>

<h2>Webový server nginx</h2>

<p>Inštaláciu webového servara opäť vykonáme klasickým debianovským spôsobom: <code>apt install nginx-full</code>.</p>

<p>Konfiguráciu začnem opäť nastavením formátu logov v hlavnom konfiguračnom súbore <code>/etc/nginx/nginx.conf</code>. Do sekcie <code>http</code> pridávam nastavenia formátu logov, ktoré sa budú jednoducho strojovo čítať:</p>

<pre>
log_format syslog_format '$request_method $status $request_time(ms) $bytes_sent(B) upstream[response=$upstream_response_time(ms) ttfb=$upstream_header_time(ms)] $remote_addr $request_uri $http_user_agent';
</pre>

<p>Konfigurácia webu <code>linxuos.sk</code> bude opäť uložená tak, aby sa dala ľahko zapínať / vypínať. Kompletná konfigurácia <code>/etc/nginx/sites-available/linuxos.sk.conf</code> vyzerá takto:</p>

<pre>
server {
	listen 80;
	listen [::]:80;

	server_name linuxos.sk;

	access_log syslog:server=unix:/dev/log,facility=local7,tag=linuxos_sk,severity=info syslog_format;

	location / {
		include uwsgi_params;
		uwsgi_pass unix:///run/uwsgi/apps/linuxos.sk/socket;
	}
}
</pre>

<p>Tento súbor v podstate len hovorí, že má počúvať na adrese linuxos.sk, porte 80 a posielať všetky požiadavky serveru <code>uwsgi</code>. Prístupové logy sú odosielané do syslogu pod značkou <code>linuxos_sk</code>. Špeciálne znaky ako napríklad bodka nie sú povolené.</p>

<p>Aby bolo možné webovú stránku načítať, je potrebné ešte pridať adresu <code>linuxos.sk</code> do <code>/etc/hosts</code>.</p>

<pre>
127.0.1.1 linuxos.sk
::1 linuxos.sk
</pre>

<p>Po vytvorení odkazu v <code>sites-enabled</code> a reloade servera <code>systemctl reload nginx</code> je možné načítať web:</p>

<pre>curl http://linuxos.sk/
Hello World
</pre>

<h2>Telemetria</h2>

<p>Za dôležitú časť starostlivosti o multihosting považujem monitoring zdrojov. Mať prehľad o rezervách vo výkone, či o nepokrytých špičkách, alebo neposlušných robotoch, ktoré nechtiac robia na server DDoS útok môže byť celkom užitočné.</p>

<p>V tomto smere sú moje skúsenosti pomerne plytké a preto ma neberte až tak celkom vážne. Na druhej strane ak poviem, bacha na databázu Prometheus a vysokú kardinalitu tak si treba dávať vážne pozor, lebo som si kvôli tomu pár krát zostrelil server. Alebo viete čo? Rovno som sa na prometheus vykašlal :)</p>

<h3>Architektúra</h3>

<p>Monitoring bude založený na 3 samostatných navzájom zameniteľných komponentoch:</p>

<dl>
	<dt>Zber údajov</dt>
	<dd>Nástroj <a href="https://github.com/influxdata/telegraf">telegraf</a> je excelentným zberačom údajov. Vie získavať informácie o systéme z rôznych zdrojov pomocou množstvá vstupných pluginov. Následne je schopný pozbierané údaje posielať do rôznych databáz cez výstupné pluginy. Typicky každý server má spustenú vlastnú inštanciu, ktorá buď aktívne zasiela údaje v pravidelných intervaloch, alebo počúva na vybranom porte a v prípade požiadavky odpovie aktuálnymi nameranými hodnotami.</dd>
	<dt>Zaznamenávanie údajov (databáza)</dt>
	<dd>Telemetrické údaje sa najlepšie zaznamenávajú do špeciálne na to určenej databázy. Na výber je napríklad Prometheus, ale vzhľadom na to, že zaznamenávam aj niektoré textové údaje som nakoniec skončil pri použití <a href="https://www.influxdata.com/">InfluxDB</a>. Databáza zvyčajne beží na jednom stroji ak nie je nevyhnutné škálovanie kvôli výkonu, alebo väčšia odolnosť voči výpadkom.</dd>
	<dt>Vizualizácia a upozornenia</dt>
	<dd>V oblasti vizualizácie zase exceluje nástroj <a href="https://grafana.com/">Grafana</a>, ktorý vie čítať a zobrazovať dáta z rôznych databáz.</dd>
</dl>

<h3>Inštalácia a nastavenie databázy InfluxDB 2.x</h3>

<p>Keďže telegraf aj grafana sa budú pripájať na databázu, je rozumné najskôr začať jej inštaláciou.</p>

<p>Podľa <a href="https://www.influxdata.com/downloads/">stránky s okazmi na stiahnutie</a> je postup inštalácie pre Debian / Ubuntu nasledovný:</p>

<pre class="code-bash">
wget -q https://repos.influxdata.com/influxdata-archive_compat.key
echo '393e8779c89ac8d958f81f942f9ad7fb82a25e133faddaf92e15b16e6ac9ce4c influxdata-archive_compat.key' | sha256sum -c &amp;&amp; cat influxdata-archive_compat.key | gpg --dearmor | tee /etc/apt/trusted.gpg.d/influxdata-archive_compat.gpg &gt; /dev/null
echo 'deb [signed-by=/etc/apt/trusted.gpg.d/influxdata-archive_compat.gpg] https://repos.influxdata.com/debian stable main' | sudo tee /etc/apt/sources.list.d/influxdata.list

apt-get update &amp;&amp; apt install influxdb2
</pre>

<p>Po úspešnej inštalácii je možné databázu naštartovať príkazom <code>systemctl start influxdb</code>. Nasledovať by mala konfigurácia, pri ktorej sa vytvoria prístupové údaje. Ja som pre všetky polia vyplnil <code>telegraf</code>, pretože som vážne lenivý a službu používam len v lokálnej sieti.</p>

<pre>
# influx setup
&gt; Welcome to InfluxDB 2.0!
? Please type your primary username telegraf
? Please type your password ********
? Please type your password again ********
? Please type your primary organization name telegraf
? Please type your primary bucket name telegraf
? Please type your retention period in hours, or 0 for infinite 72
? Setup with these parameters?
  Username:          telegraf
  Organization:      telegraf
  Bucket:            telegraf
  Retention Period:  72h0m0s
 Yes
User            Organization    Bucket
telegraf        telegraf        telegraf
</pre>

<p>Pre autentifikáciu bude vyžadovaný token, ktorý je možné zistiť príkazom <code>influx auth list</code>:</p>

<pre>
ID                      Description             Token                                                                                           User Name       User ID                 Permissions
0c262a48f390a000        telegraf's Token        <strong>_IQwe0LFcZgILzW-Blre9E9s80FUCo8SgU0lrxAZB-BPFg-HGJvd0zqEMXfL8-YcBR7olvMppvCyQY8_YX6izg==</strong>        telegraf        0c262a48de90a000        [read:/authorizations write:/authorizations read:/buckets write:/buckets read:/dashboards write:/dashboards read:/orgs write:/orgs read:/sources write:/sources read:/tasks write:/tasks read:/telegrafs write:/telegrafs read:/users write:/users read:/variables write:/variables read:/scrapers write:/scrapers read:/secrets write:/secrets read:/labels write:/labels read:/views write:/views read:/documents write:/documents read:/notificationRules write:/notificationRules read:/notificationEndpoints write:/notificationEndpoints read:/checks write:/checks read:/dbrp write:/dbrp read:/notebooks write:/notebooks read:/annotations write:/annotations read:/remotes write:/remotes read:/replications write:/replications]
</pre>

<h3>Inštalácia a nastavenie telegrafu</h3>

<p>Návod na inštaláciu pre Ubuntu / Debian sa prakticky nelíši od od InfluxDB a pozostáva z pridania repozitára a klasickú inštaláciu cez apt:</p>

<pre class="code-bash">
wget -q https://repos.influxdata.com/influxdata-archive_compat.key
echo '393e8779c89ac8d958f81f942f9ad7fb82a25e133faddaf92e15b16e6ac9ce4c influxdata-archive_compat.key' | sha256sum -c &amp;&amp; cat influxdata-archive_compat.key | gpg --dearmor | tee /etc/apt/trusted.gpg.d/influxdata-archive_compat.gpg &gt; /dev/null
echo 'deb [signed-by=/etc/apt/trusted.gpg.d/influxdata-archive_compat.gpg] https://repos.influxdata.com/debian stable main' | tee /etc/apt/sources.list.d/influxdata.list
apt-get update &amp;&amp; apt install telegraf
</pre>

<h4>Minimálna konfigurácia</h4>

<p>Zatiaľ budem ignorovať štandardný a začnem úplne jednoduchým čistým konfiguračným súborom <code>telegraf.conf</code>:</p>

<pre class="code-ini">
[[outputs.file]]
	files = ["/tmp/telegraf.out"]

[[inputs.mem]]
</pre>

<p>Po spustení <code>telegraf --config telegraf.conf --debug</code> sa v konzole zobrazí výpis podobný tomuto:</p>

<pre>
2023-11-25T16:09:09Z I! Starting Telegraf 1.22.3+ds1-0ubuntu2
2023-11-25T16:09:09Z I! Loaded inputs: mem
2023-11-25T16:09:09Z I! Loaded aggregators:
2023-11-25T16:09:09Z I! Loaded processors:
2023-11-25T16:09:09Z I! Loaded outputs: file
2023-11-25T16:09:09Z I! Tags enabled: host=linuxos
2023-11-25T16:09:09Z I! [agent] Config: Interval:10s, Quiet:false, Hostname:"linuxos", Flush Interval:10s
2023-11-25T16:09:09Z D! [agent] Initializing plugins
2023-11-25T16:09:09Z D! [agent] Connecting outputs
2023-11-25T16:09:09Z D! [agent] Attempting connection to [outputs.file]
2023-11-25T16:09:09Z D! [agent] Successfully connected to outputs.file
2023-11-25T16:09:09Z D! [agent] Starting service inputs
2023-11-25T16:09:19Z D! [outputs.file] Wrote batch of 1 metrics in 142.651µs
2023-11-25T16:09:19Z D! [outputs.file] Buffer fullness: 0 / 10000 metrics
2023-11-25T16:09:29Z D! [outputs.file] Wrote batch of 1 metrics in 126.871µs
2023-11-25T16:09:29Z D! [outputs.file] Buffer fullness: 0 / 10000 metrics
</pre>

<p>Zaujímavejšie však vyzerá súbor <code>/tmp/telegraf.out</code>.</p>

<pre>
mem,host=linuxos total=8317620224i,inactive=2522996736i,shared=848220160i,write_back=0i,available=3538952192i,huge_pages_free=0i,sreclaimable=1049927680i,swap_total=536866816i,used=3613786112i,commit_limit=4695674880i,high_free=0i,mapped=1177395200i,vmalloc_total=35184372087808i,vmalloc_used=24809472i,buffered=84185088i,slab=1203593216i,swap_cached=87453696i,cached=3088490496i,committed_as=78690824192i,low_total=0i,available_percent=42.547653014843874,dirty=3010560i,high_total=0i,huge_pages_total=0i,vmalloc_chunk=0i,active=2959667200i,huge_page_size=2097152i,low_free=0i,sunreclaim=153665536i,used_percent=43.44735651157328,free=1531158528i,page_tables=32088064i,swap_free=2609152i,write_back_tmp=0i 1700928550000000000
mem,host=linuxos committed_as=78680104960i,huge_pages_total=0i,low_total=0i,vmalloc_total=35184372087808i,available=3531640832i,commit_limit=4695674880i,swap_cached=87453696i,swap_free=2609152i,swap_total=536866816i,vmalloc_used=24866816i,active=2950438912i,free=1522753536i,low_free=0i,vmalloc_chunk=0i,high_free=0i,huge_pages_free=0i,huge_page_size=2097152i,sunreclaim=153661440i,available_percent=42.45975094907146,buffered=84221952i,high_total=0i,shared=848220160i,slab=1203658752i,sreclaimable=1049997312i,write_back=0i,used_percent=43.535209332490915,dirty=4239360i,mapped=1167822848i,total=8317620224i,used=3621093376i,page_tables=30720000i,write_back_tmp=0i,cached=3089551360i,inactive=2523975680i 1700928560000000000
mem,host=linuxos cached=3089911808i,huge_pages_total=0i,mapped=1167765504i,swap_cached=87457792i,buffered=84238336i,commit_limit=4695674880i,high_total=0i,swap_total=536866816i,vmalloc_total=35184372087808i,total=8317620224i,dirty=1708032i,inactive=2524303360i,low_total=0i,free=1534955520i,high_free=0i,huge_pages_free=0i,shared=848220160i,sunreclaim=153698304i,vmalloc_used=24842240i,write_back=0i,available_percent=42.61103114293861,active=2949169152i,committed_as=78673256448i,page_tables=30531584i,sreclaimable=1050013696i,available=3544223744i,used=3608514560i,write_back_tmp=0i,huge_page_size=2097152i,slab=1203712000i,swap_free=2658304i,vmalloc_chunk=0i,used_percent=43.38397838347855,low_free=0i 1700928570000000000
</pre>

<p>Zo vstupných pluginov je povolené len zaznamenávanie obsadenej pamäte. Teraz si bližšie rozoberieme jednotlivé polia súboru. V budúcnosti tento postup bude slúžiť ako pomôcka pri konfigurácii a prezeraní dostupných dát</p>

<p>Prvým poľom na každom riadku je vždy názov metriky. V tomto prípade je to <code>mem</code>. Nasleduje zoznam čiarkou oddelených tagov vo forme <code>názov=hodnota</code>. V tomto prípade je názov tagu <code>host</code> a hodnota <code>linuxos</code>. Tagy sú polia, podľa ktorých sú dáta indexované a je možné ich rýchlo prehľadávať. Na druhej strane je nevhodné do tagov ukladať dáta, ktoré majú veľký počet rozličných hodnôt. V riadku ďalej nasleduje zoznam nameraných hodnôt v rovnakej forme, v akej bol zoznam tagov. Posledným poľom je časová pečiatka merania.</p>

<h4>Odosielanie dát do InfluxDB</h4>

<p>Vo väčšine prípadov budeme chcieť ukladať namerané hodnoty do reálnej databázy. Po pridaní nasledujúcej sekcie sa budú údaje zasielať do InfluxDB:</p>

<pre class="code-ini">
[[outputs.influxdb_v2]]
	urls = ["http://127.0.0.1:8086"]
	token = "_IQwe0LFcZgILzW-Blre9E9s80FUCo8SgU0lrxAZB-BPFg-HGJvd0zqEMXfL8-YcBR7olvMppvCyQY8_YX6izg=="
	organization = "telegraf"
	bucket = "telegraf"
</pre>

<p>URL adresu je potrebné nastaviť podľa hostiteľa a portu, na ktorom beží InfluxDB. Prístupový token je možné získať príkazom <code>influx auth list</code> použitým pri inštalácii InfluxDB. Názov organizácie a bucketu musia zodpovedať názvom použitým pri inštalácii.</p>

<h4>Príprava parsovania logov</h4>

<p>Okrem bežných metrík budeme zaznamenávať aj niektoré zaujímavé informácie z logov webového serveru nginx a aplikačného serveru uwsgi. V nasledujúcom výpise je ukážka nginx logu získaného príkazom <code>journalctl -f -o short-iso -u nginx.service</code>:</p>

<pre>
2023-11-25T17:30:47+0100 linuxos nginx[3852772]: linuxos linuxos_sk: GET 302 0.003(ms) 486(B) upstream[response=0.003(ms) ttfb=0.003(ms)] x.x.x.181 /currency/set/?currency=EUR Mozilla/5.0
2023-11-25T17:30:47+0100 linuxos nginx[3852774]: linuxos linuxos_sk: POST 200 0.028(ms) 867(B) upstream[response=0.027(ms) ttfb=0.027(ms)] x.x.x.54 /accounts/signup/ Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/119.0
</pre>

<p>Do pozornosti dávam názov webu <code>linuxos_sk</code>, ktorý sa nedal zapísať s bodkou. Našťastie je možné problém veľmi jednoducho napraviť pomocou nástroja <code>awk</code>. Výsledný skript <code>/etc/telegraf/scripts/read_nginx_log.sh</code> bude vyzerať nasledovne:</p>

<pre class="code-bash">
#!/bin/bash
/usr/bin/journalctl -f -o short-iso -u nginx.service|awk '\
{\
	gsub(/_/, ".", $5);\
	print\
}'
</pre>

<p>Podobným spôsobom bude implementovaný skript pre čítanie uwsgi logov. Konfigurácia bude o niečo zložitejšia, keďže tu sa spracúva dĺžka behu skriptu, z rýchlych dotazov sa odstráni URL adresa a otagujú sa značkou <code>fast</code>. Pomalé sa zase otagujú značkou <code>slow</code> a URL adresa zostane. Takto vyzerá skript <code>/etc/telegraf/scripts/read_uwsgi_log.sh</code>:</p>

<pre class="cod-bash">
#!/bin/bash
/usr/bin/journalctl -f -o short-iso -u emperor.uwsgi.service | awk '\
{\
	time = substr($6, 1, length($6)-2);\
	speed = "slow";\
	if (time+0 &lt; 1000) {\
		$8 = "∅";\
		speed = "fast"\
	}\
	print $1, $2, $3, $4, $5, $6, $7, speed, $8\
}'
</pre>

<p>Výsledný log vyzerá približne takto:</p>

<pre>
2023-11-25T17:45:42+0100 linuxos linuxos.sk[288892]: GET 200 112ms 103501b fast ∅
2023-11-25T17:45:43+0100 linuxos linuxos.sk[288892]: GET 200 148ms 108156b fast ∅
2023-11-25T17:45:44+0100 linuxos linuxos.sk[288892]: GET 200 93ms 102613b fast ∅
</pre>

<h4>Kompletná konfigurácia</h4>

<p>V tejto časti si prejdeme plne funkčný konfiguračný súbor pre telegraf. Finálny <code>/etc/telegraf/telegraf.conf</code> vyzerá takto:</p>

<pre class="code-ini">
# Ukladanie do InfluxDB
[[outputs.influxdb_v2]]
	urls = ["http://127.0.0.1:8086"]
	token = "_IQwe0LFcZgILzW-Blre9E9s80FUCo8SgU0lrxAZB-BPFg-HGJvd0zqEMXfL8-YcBR7olvMppvCyQY8_YX6izg=="
	organization = "telegraf"
	bucket = "telegraf"


# Aktivita CPU
[[inputs.cpu]]
	percpu = true
	totalcpu = true
	collect_cpu_time = false
	report_active = false


# Zaplnenie disku
[[inputs.disk]]
	ignore_fs = ["tmpfs", "devtmpfs", "devfs", "iso9660", "overlay", "aufs", "squashfs"]


# Monitorovanie RAM
[[inputs.mem]]


# Monitorovanie siete
[[inputs.net]]
	interfaces = ["eth0"]


# Monitorovanie procesov (+ pridanie tagov socket podľa používateľa)
[[inputs.procstat]]
	user = "linuxos.sk"
	[inputs.procstat.tags]
		socket = "linuxos.sk"

[[inputs.procstat]]
	user = "mirec"
	[inputs.procstat.tags]
		socket = "mirec.sk"


# Monitorovanie uWSGI procesov
[[inputs.uwsgi]]
	servers = ["unix:///run/uwsgi/stats/linuxos.sk.sock"]
	[inputs.uwsgi.tags]
		socket = "linuxos.sk"

[[inputs.uwsgi]]
	servers = ["unix:///run/uwsgi/stats/mirec.sk.sock"]
	[inputs.uwsgi.tags]
		socket = "mirec.sk"


# Ukladanie uWSGI logov (kvôli záznamu najpomalších URL)
[[inputs.execd]]
	command = ["/etc/telegraf/scripts/read_uwsgi_log.sh"]
	grok_patterns = ['%{TIMESTAMP_ISO8601:timestamp} %{DATA:username} uwsgi-%{DATA:socket:tag}\[%{NUMBER:pid:int}\]: %{DATA:method:tag} %{NUMBER:response_code:tag} %{NUMBER:uwsgi_request_time:float}ms %{NUMBER:bytes:int}b %{WORD:speed:tag} %{GREEDYDATA:url}']
	data_format = "grok"
	name_override = "uwsgi_requests"
	fielddrop = ["username", "pid"]


# Rovnaké spracovanie uWSGI logov, tentoraz za účelom výpočtu histogramu
[[inputs.execd]]
	command = ["/etc/telegraf/scripts/read_uwsgi_log.sh"]
	grok_patterns = ['%{TIMESTAMP_ISO8601:timestamp} %{DATA:username} uwsgi-%{DATA:socket:tag}\[%{NUMBER:pid:int}\]: %{DATA:method} %{NUMBER:response_code} %{NUMBER:uwsgi_request_time:float}ms %{NUMBER:bytes:int}b %{WORD:speed} %{GREEDYDATA:url}']
	data_format = "grok"
	name_override = "uwsgi_requests_histogram"
	fielddrop = ["timestamp", "username", "pid", "method", "response_code", "bytes", "speed", "url"]


# Rozdelenie počtu requestov do bucketov podľa trvanie requestu po 20ms
[[aggregators.histogram]]
	period = "120s"
	drop_original = true
	reset = true
	cumulative = false
	namepass = ["uwsgi_requests_histogram"]
	[[aggregators.histogram.config]]
		measurement_name = "uwsgi_requests_histogram"
		fields = ["uwsgi_request_time"]
		buckets = [20.0, 40.0, 60.0, 80.0, 100.0, 120.0, 140.0, 160.0, 180.0, 200.0, 220.0, 240.0, 260.0, 280.0, 300.0, 320.0, 340.0, 360.0, 380.0, 400.0, 420.0, 440.0, 460.0, 480.0, 500.0, 520.0, 540.0, 560.0, 580.0, 600.0, 620.0, 640.0, 660.0, 680.0, 700.0, 720.0, 740.0, 760.0, 780.0, 800.0, 820.0, 840.0, 860.0, 880.0, 900.0, 920.0, 940.0, 960.0, 980.0, 1000.0, 60000.0]


# Spracovanie logov nginx
[[inputs.execd]]
	command = ["/etc/telegraf/scripts/read_nginx_log.sh"]
	data_format = "grok"
	grok_patterns = ["%{TIMESTAMP_ISO8601:timestamp} %{WORD:server} nginx\\[%{NUMBER:nginx_pid}\\]: %{DATA:server_name} %{DATA:socket:tag}: %{WORD:http_method:tag} %{NUMBER:http_status:tag} %{NUMBER:request_time:float}\\(ms\\) %{NUMBER:bytes_sent:int}\\(B\\) upstream\\[response=%{NUMBER:upstream_response_time:float}\\(ms\\) ttfb=%{NUMBER:upstream_ttfb:float}\\(ms\\)\\] %{IP:client_ip} %{DATA:request_path} %{GREEDYDATA:user_agent}"]
	fielddrop = ["server", "nginx_pid", "server_name", "client_ip", "request_path", "user_agent", "bytes_sent", "upstream_response_time", "ttfb"]
	name_override = "nginx_access"
</pre>

<p>Vstup <code>inputs.cpu</code> slúži na monitorovanie stavu CPU. V čase písania článku tento modul exportuje tag <code>cpu</code> s číslom jadra (cpux alebo cpu-total) a polia:</p>

<ul>
	<li>time_user</li>
	<li>time_system</li>
	<li>time_idle</li>
	<li>time_nice</li>
	<li>time_iowait</li>
	<li>time_irq</li>
	<li>time_softirq</li>
	<li>time_steal</li>
	<li>time_guest</li>
	<li>time_guest_nice</li>
	<li>usage_user (%)</li>
	<li>usage_system (%)</li>
	<li>usage_idle (%)</li>
	<li>usage_nice (%)</li>
	<li>usage_iowait (%)</li>
	<li>usage_irq (%)</li>
	<li>usage_softirq (%)</li>
	<li>usage_steal (%)</li>
	<li>usage_guest (%)</li>
	<li>usage_guest_nice (%)</li>
</ul>

<p>Ďalší vstup <code>inputs.disk</code> slúži na zaznamenávanie zaplnenia disku. Dostupné tagy sú:</p>

<ul>
	<li>fstype (typ FS)</li>
	<li>device (názov zariadenia)</li>
	<li>path (cesta k bodu pripojenia)</li>
	<li>mode (rw / ro podľa toho, či je pripojený na zápis/čítanie)</li>
	<li>label (devicemapper štítok)</li>
</ul>

<p>Z polí máme k dispozícii:</p>

<ul>
	<li>free (byty)</li>
	<li>total (byty)</li>
	<li>used (byty)</li>
	<li>used_percent (%)</li>
	<li>inodes_free (počet súborov)</li>
	<li>inodes_total (počet súborov)</li>
	<li>inodes_used (počet súborov)</li>
	<li>inodes_used_percent (%)</li>
</ul>

<p>Ďalšie 2 sekcie slúžia na konfiguráciu zaznamenávania stavu <code>RAM</code> a sieťovej karty <code>eth0</code>.</p>

<p>Zaujímavejšou sekciou je <code>inputs.procstat</code>, ktorá slúži na zaznamenávanie štatistík o procesoch. Nakonfigurovaných je niekoľko vstupov, pričom vstupy sú filtrované podľa používateľa. Každý vstup má nakonfigurovanú značku <code>socket</code>, aby bolo možné dáta zoradiť podľa konkrétneho webu.</p>

<p>Konfiguráciu štatistík v nastavení uWSGI sme samozrejme nerobili len tak prenič-zanič. Nástroj telegraf vstavanú podporu pre čítanie štatistík uWSGI pomocou sekcie <code>inputs.uwsgi</code>. Podobne, ako pri <code>inputs.procstat</code> je aj tu nakonfigurované značkovanie webu do tagu <code>socket</code>.</p>

<p>Skutočná zábava sa začína až teraz pri vstupoch, ktoré obsahujú grok_patterns. Teda začala by … nebyť ChatGPT 4. Ja nepoznám formát patternu grok_paterns, dokonca som ani nepoznal spôsob, ako nakonfigurovať <code>telegraf</code> tak, aby čítal log. Napísal som však požiadavku pre ChatGPT4, aby mi napísal konfiguráciu telegrafu pre čítanie logu, pridal som jeden riadok z logu ako ukážku a on na mňa vyhodil:</p>

<pre class="code-ini">
[[inputs.execd]]
	command = ["/etc/telegraf/scripts/read_uwsgi_log.sh"]
	grok_patterns = ['%{TIMESTAMP_ISO8601:timestamp} %{DATA:username} uwsgi-%{DATA:socket:tag}\[%{NUMBER:pid:int}\]: %{DATA:method:tag} %{NUMBER:response_code:tag} %{NUMBER:uwsgi_request_time:float}ms %{NUMBER:bytes:int}b %{WORD:speed:tag} %{GREEDYDATA:url}']
	data_format = "grok"
	name_override = "uwsgi_requests"
	fielddrop = ["username", "pid"]
</pre>

<p>Vážne, neviem ako sa to konfiguruje a nebyť ChatGPT by som sa trápil veľmi dlho. Výsledkom je pekne štruktúrovaný vstup, ktorý je správne otagovaný a odosielaný do InfluxDB.</p>

<p>Druhý prakticky identický vstup <code>inputs.execd</code> slúži ako vstup pre výpočet histogramu. Agregačná funkcia <code>aggregators.histogram</code> automaticky sčítava výskyty záznamu podľa ich hodnoty a tagov do jednotlivých bucketov. To je aj dôvod, prečo druhý vstup neobsahuje napríklad tag <code>speed</code>.</p>

<p>Nakoniec tu máme spracovanie logu webového servera. Rovnako ako v prípade uWSGI som požiadal ChatGPT o napísanie konfigurácie. Zase bez problémov sám a bez našepkávania rozpoznal polia v logu a všetko viac-menej správne priradil s použitím minimálneho kontextu. Konečne mám kolegu, ktorému môžem nakladať špinavú prác!</p>

<h2>Grafana</h2>

<p>Pre inštaláciu je podľa <a href="https://grafana.com/docs/grafana/latest/setup-grafana/installation/debian/">dokumentácie</a> potrebné vykonať niekoľko príkazov:</p>

<pre class="code-bash">
apt-get install -y apt-transport-https software-properties-common wget
mkdir -p /etc/apt/keyrings/
wget -q -O - https://apt.grafana.com/gpg.key | gpg --dearmor | tee /etc/apt/keyrings/grafana.gpg &gt; /dev/null
echo "deb [signed-by=/etc/apt/keyrings/grafana.gpg] https://apt.grafana.com stable main" | tee -a /etc/apt/sources.list.d/grafana.list
echo "deb [signed-by=/etc/apt/keyrings/grafana.gpg] https://apt.grafana.com beta main" | tee -a /etc/apt/sources.list.d/grafana.list
apt-get update
apt-get install grafana
</pre>

<p>Následne sa grafana naštartuje príkazom <code>systemctl start grafana-server</code>. Teraz stačí povoliť pripojenie na port 3000 (napríklad <code>ufw allow 3000</code>) a po načítaní adresy <code>http://adresa-servera:3000/</code> v prehliadači by sa malo zobraziť prihlasovacie okno.</p>

<figure>
	<a href="img/login.png"><img src="img/login.png" alt="Prihlasovacie okno grafana" /></a>
	<figcaption>Obrázok <counter></counter>: Prihlasovacie okno grafana</figcaption>
</figure>

<p>Úvodné prihlasovacie meno a heslo je <code>admin / admin</code>.</p>

<p>Ďalej je potrebné nastaviť zdroj dát. Ten sa nastavuje cez Menu / Connections a z dostupných spojení vyberieme <em>InfluxDB</em>. Dôležité je vybrať jazyk <em>Flux</em>. Následne je potrebné nastaviť minimálne URL adresu a prihlasovacie údaje tak, ako boli nastavené v konfigurácii telegrafu.</p>

<figure>
	<a href="img/influxdb_source.png"><img src="img/influxdb_source.png" alt="Pridanie InfluxDB zdroja" /></a>
	<figcaption>Obrázok <counter></counter>: Pridanie InfluxDB zdroja</figcaption>
</figure>

<p>Následne sa môžeme začať hrať s dátami kliknutím na <em>Explore data</em>.</p>

<p>Na rozdiel do zdrojov Prometheux, alebo InfluxDB s jazykom InfluxQL nie je pre jazyk Flux dostupný grafický editor. Všetky dotazy preto musia byť písané ručne pomocou textového editoru.</p>

<figure>
	<a href="img/cpu_query_1.png"><img src="img/cpu_query_1.png" alt="Dotaz na CPU" /></a>
	<figcaption>Obrázok <counter></counter>: Dotaz na CPU</figcaption>
</figure>

<p>Graf CPU bol vykreslený nasledujúcim príkazom:</p>

<pre>
from(bucket: "telegraf")
  |&gt; range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |&gt; filter(fn: (r) =&gt; r._measurement == "cpu" and r.cpu == "cpu-total" and r._field == "usage_idle")
</pre>

<p>Príkaz <code>from</code> vyberá bucket, z ktorého bud čítané dáta. Nasleduje obmedzenie časového rozsahu pomocou premennej <code>v</code>. Túto premennú nastavuje automaticky grafana podľa rozsahu dát, ktoré má používateľ nastavený. Ďalej nasleduje konkrétny výber dát. Tu zdôrazňujem, že každé pole v dátach je reprezentované ako samostatný riadok. Riadky majú priradené tagy ako <code>r.tag</code>. Riadky obsahujú aj implicitné premenné začínajúce sa na znak <code>_</code>. Sú to napríklad:</p>

<dl>
	<dt>_measurement</dt>
	<dd>Názov metriky</dd>
	<dt>_field</dt>
	<dd>Názov poľa</dd>
	<dt>_value</dt>
	<dd>Hodnota poľa</dd>
	<dt>_time</dt>
	<dd>Časová pečiatka</dd>
</dl>

<p>V štatistikách CPU nie je k dispozícii celkové zaťaženie, ale máme tu k dispozícii pole <code>usage_idle</code>. Ak by sme chceli zobraziť celkové zaťaženie, stačí nám odčítať doby nečinnosti od <code>100%</code>. Na konci dotazu stačí jednoducho pridať funkciu <code>map</code>, ktorá aplikuje funkciu na každý bod:</p>

<pre>
from(bucket: "telegraf")
  |&gt; range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |&gt; filter(fn: (r) =&gt; r._measurement == "cpu" and r.cpu == "cpu-total" and r._field == "usage_idle")
  |&gt; <strong>map(fn: (r) =&gt; ({ r with _value: 100.0 - r._value }))</strong>
</pre>

<figure>
	<a href="img/cpu_query_2.png"><img src="img/cpu_query_2.png" alt="Záťaž CPU" /></a>
	<figcaption>Obrázok <counter></counter>: Záťaž CPU</figcaption>
</figure>

<p>Tento dotaz je vysoko neoptimálny, pretože vyberá všetky dátové body bez ohľadu na to, či je zobrazený graf široký, alebo úzky. Grafana má automatickú premennú <code>v.windowPeriod</code>, ktorá určuje, aký časový úsek zaberá približne pixel v zobrazenom grafe. Pri zobrazení záťaže CPU je ideálne rozdeliť dáta na časové okná a v každom časovom okne vypočítať priemernú hodnotu. Presne na toto slúži funkcia <code>aggregateWindow</code>:</p>

<pre>
from(bucket: "telegraf")
  |&gt; range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |&gt; filter(fn: (r) =&gt; r._measurement == "cpu" and r.cpu == "cpu-total" and r._field == "usage_idle")
  |&gt; map(fn: (r) =&gt; ({ r with _value: 100.0 - r._value }))
  |&gt; <strong>aggregateWindow(every: v.windowPeriod, fn: mean)</strong>
</pre>

<p>Momentálne prijímame síce dáta len z jediného serveru, ale v reálnom nasadení môžeme mať serverov výrazne viacej. Preto je vhodné nastaviť zoskupenie dát podľa hostiteľa, vďaka čomu budú v grafe jednotlivé servery zobrazené samostatnou krivkou. Zoskupenie sa nastavuje volaním funkcie <code>group</code> pred agregačnou funkciou.</p>

<pre>
from(bucket: "telegraf")
  |&gt; range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |&gt; filter(fn: (r) =&gt; r._measurement == "cpu" and r.cpu == "cpu-total" and r._field == "usage_idle")
  |&gt; map(fn: (r) =&gt; ({ r with _value: 100.0 - r._value }))
  |&gt; <strong>group(columns: ["host"])</strong>
  |&gt; aggregateWindow(every: v.windowPeriod, fn: mean)
</pre>

<p>Nový dashboard sa dá vytvoriť kliknutím na tlačidlo <em>Add to dashboard</em>.</p>

<p>Nasleduje malá ukážka nastavení grafu CPU:</p>

<figure>
	<a href="img/cpu_settings.png"><img src="img/cpu_settings.png" alt="Nastavenia CPU" /></a>
	<figcaption>Obrázok <counter></counter>: Nastavenia CPU</figcaption>
</figure>

<p>Výsledný graf môže vyzerať celkom elegantne:</p>

<figure>
	<a href="img/cpu_configured.png"><img src="img/cpu_configured.png" alt="Nastavený graf" /></a>
	<figcaption>Obrázok <counter></counter>: Nastavený graf</figcaption>
</figure>

</article>
<script src="../../../common/script.js"></script>
</body>
</html>
